From d26cedc99224c695a21b464e73ac112045090834 Mon Sep 17 00:00:00 2001
From: Kai Lueke <kailuke@microsoft.com>
Date: Fri, 29 Sep 2023 18:06:09 +0200
Subject: [PATCH] sgdisk: Run partx after partition changes

The sgdisk tool does not update the kernel partition table with BLKPG in
contrast to other similar tools but only uses BLKRRPART which fails as
soon as one partition of the disk is mounted.
Update the kernel partition table with partx when we know that a
partition of the disk is in use.
---
 docs/release-notes.md                    |  1 +
 dracut/30ignition/module-setup.sh        |  1 +
 internal/distro/distro.go                |  2 ++
 internal/exec/stages/disks/partitions.go | 34 ++++++++++++++++++++++++
 4 files changed, 38 insertions(+)

diff --git a/docs/release-notes.md b/docs/release-notes.md
index db49c304..ce97d2d8 100644
--- a/docs/release-notes.md
+++ b/docs/release-notes.md
@@ -14,6 +14,7 @@ nav_order: 9
 
 ### Changes
 
+- The Dracut module now installs partx
 
 ### Bug fixes
 
diff --git a/dracut/30ignition/module-setup.sh b/dracut/30ignition/module-setup.sh
index d7a5cfcd..86fd892e 100755
--- a/dracut/30ignition/module-setup.sh
+++ b/dracut/30ignition/module-setup.sh
@@ -33,6 +33,7 @@ install() {
         mkfs.xfs \
         mkswap \
         sgdisk \
+        partx \
         useradd \
         userdel \
         usermod \
diff --git a/internal/distro/distro.go b/internal/distro/distro.go
index 9e96166e..f295a572 100644
--- a/internal/distro/distro.go
+++ b/internal/distro/distro.go
@@ -44,6 +44,7 @@ var (
 	mdadmCmd     = "mdadm"
 	mountCmd     = "mount"
 	sgdiskCmd    = "sgdisk"
+	partxCmd     = "partx"
 	modprobeCmd  = "modprobe"
 	udevadmCmd   = "udevadm"
 	usermodCmd   = "usermod"
@@ -100,6 +101,7 @@ func GroupdelCmd() string  { return groupdelCmd }
 func MdadmCmd() string     { return mdadmCmd }
 func MountCmd() string     { return mountCmd }
 func SgdiskCmd() string    { return sgdiskCmd }
+func PartxCmd() string     { return partxCmd }
 func ModprobeCmd() string  { return modprobeCmd }
 func UdevadmCmd() string   { return udevadmCmd }
 func UsermodCmd() string   { return usermodCmd }
diff --git a/internal/exec/stages/disks/partitions.go b/internal/exec/stages/disks/partitions.go
index 7c1bd272..5dd261a4 100644
--- a/internal/exec/stages/disks/partitions.go
+++ b/internal/exec/stages/disks/partitions.go
@@ -24,6 +24,7 @@ import (
 	"fmt"
 	"io/ioutil"
 	"os"
+	"os/exec"
 	"path/filepath"
 	"regexp"
 	"sort"
@@ -32,6 +33,7 @@ import (
 
 	cutil "github.com/flatcar/ignition/v2/config/util"
 	"github.com/flatcar/ignition/v2/config/v3_5_experimental/types"
+	"github.com/flatcar/ignition/v2/internal/distro"
 	"github.com/flatcar/ignition/v2/internal/exec/util"
 	"github.com/flatcar/ignition/v2/internal/sgdisk"
 )
@@ -478,6 +480,10 @@ func (s stage) partitionDisk(dev types.Disk, devAlias string) error {
 		return err
 	}
 
+	var partxAdd []uint64
+	var partxDelete []uint64
+	var partxUpdate []uint64
+
 	for _, part := range resolvedPartitions {
 		shouldExist := partitionShouldExist(part)
 		info, exists := diskInfo.GetPartition(part.Number)
@@ -507,11 +513,13 @@ func (s stage) partitionDisk(dev types.Disk, devAlias string) error {
 		case !exists && shouldExist:
 			op.CreatePartition(part)
 			modification = true
+			partxAdd = append(partxAdd, uint64(part.Number))
 		case exists && !shouldExist && !wipeEntry:
 			return fmt.Errorf("partition %d exists but is specified as nonexistant and wipePartitionEntry is false", part.Number)
 		case exists && !shouldExist && wipeEntry:
 			op.DeletePartition(part.Number)
 			modification = true
+			partxDelete = append(partxDelete, uint64(part.Number))
 		case exists && shouldExist && matches:
 			s.Logger.Info("partition %d found with correct specifications", part.Number)
 		case exists && shouldExist && !wipeEntry && !matches:
@@ -525,6 +533,7 @@ func (s stage) partitionDisk(dev types.Disk, devAlias string) error {
 				part.StartSector = &info.StartSector
 				op.CreatePartition(part)
 				modification = true
+				partxUpdate = append(partxUpdate, uint64(part.Number))
 			} else {
 				return fmt.Errorf("Partition %d didn't match: %v", part.Number, matchErr)
 			}
@@ -533,6 +542,7 @@ func (s stage) partitionDisk(dev types.Disk, devAlias string) error {
 			op.DeletePartition(part.Number)
 			op.CreatePartition(part)
 			modification = true
+			partxUpdate = append(partxUpdate, uint64(part.Number))
 		default:
 			// unfortunatey, golang doesn't check that all cases are handled exhaustively
 			return fmt.Errorf("Unreachable code reached when processing partition %d. golang--", part.Number)
@@ -547,6 +557,30 @@ func (s stage) partitionDisk(dev types.Disk, devAlias string) error {
 		return fmt.Errorf("commit failure: %v", err)
 	}
 
+	// In contrast to similar tools, sgdisk does not trigger the update of the
+	// kernel partition table with BLKPG but only uses BLKRRPART which fails
+	// as soon as one partition of the disk is mounted
+	if len(activeParts) > 0 {
+		for _, partNr := range partxDelete {
+			cmd := exec.Command(distro.PartxCmd(), "--delete", "--nr", strconv.FormatUint(partNr, 10), blockDevResolved)
+			if _, err := s.Logger.LogCmd(cmd, "triggering partition %d deletion on %q", partNr, devAlias); err != nil {
+				return fmt.Errorf("deleting partition failed: %v", err)
+			}
+		}
+		for _, partNr := range partxUpdate {
+			cmd := exec.Command(distro.PartxCmd(), "--update", "--nr", strconv.FormatUint(partNr, 10), blockDevResolved)
+			if _, err := s.Logger.LogCmd(cmd, "triggering partition %d re-read on %q", partNr, devAlias); err != nil {
+				return fmt.Errorf("updating partition failed: %v", err)
+			}
+		}
+		for _, partNr := range partxAdd {
+			cmd := exec.Command(distro.PartxCmd(), "--add", "--nr", strconv.FormatUint(partNr, 10), blockDevResolved)
+			if _, err := s.Logger.LogCmd(cmd, "triggering partition %d addition on %q", partNr, devAlias); err != nil {
+				return fmt.Errorf("adding partition failed: %v", err)
+			}
+		}
+	}
+
 	// It's best to wait here for the /dev/ABC entries to be
 	// (re)created, not only for other parts of the initramfs but
 	// also because s.waitOnDevices() can still race with udev's
-- 
2.43.0

