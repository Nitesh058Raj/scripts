From 5b60516463dceceb9fe2170945fb2ce644f2d5aa Mon Sep 17 00:00:00 2001
Message-Id: <5b60516463dceceb9fe2170945fb2ce644f2d5aa.1709043678.git.dpark@linux.microsoft.com>
In-Reply-To: <c1cac21cfdb52c17b663a4daf266298f80cae6fb.1709043678.git.dpark@linux.microsoft.com>
References: <c1cac21cfdb52c17b663a4daf266298f80cae6fb.1709043678.git.dpark@linux.microsoft.com>
From: Dongsu Park <dpark@linux.microsoft.com>
Date: Tue, 27 Feb 2024 15:17:24 +0100
Subject: [PATCH 08/13] Revert "x86/boot: Set EFI handover offset directly in
 header asm"

This reverts commit 431b39e62594c440dd8f80591a1d928f2095db13.
---
 arch/x86/boot/header.S      | 18 +-----------------
 arch/x86/boot/tools/build.c | 24 ++++++++++++++++++++++++
 2 files changed, 25 insertions(+), 17 deletions(-)

diff --git a/arch/x86/boot/header.S b/arch/x86/boot/header.S
index 72744ba4..5575d0f0 100644
--- a/arch/x86/boot/header.S
+++ b/arch/x86/boot/header.S
@@ -524,24 +524,8 @@ pref_address:		.quad LOAD_PHYSICAL_ADDR	# preferred load addr
 # define INIT_SIZE VO_INIT_SIZE
 #endif
 
-	.macro		__handover_offset
-#ifndef CONFIG_EFI_HANDOVER_PROTOCOL
-	.long		0
-#elif !defined(CONFIG_X86_64)
-	.long		ZO_efi32_stub_entry
-#else
-	/* Yes, this is really how we defined it :( */
-	.long		ZO_efi64_stub_entry - 0x200
-#ifdef CONFIG_EFI_MIXED
-	.if		ZO_efi32_stub_entry != ZO_efi64_stub_entry - 0x200
-	.error		"32-bit and 64-bit EFI entry points do not match"
-	.endif
-#endif
-#endif
-	.endm
-
 init_size:		.long INIT_SIZE		# kernel initialization size
-handover_offset:	__handover_offset
+handover_offset:	.long 0			# Filled in by build.c
 kernel_info_offset:	.long ZO_kernel_info
 
 # End of setup header #####################################################
diff --git a/arch/x86/boot/tools/build.c b/arch/x86/boot/tools/build.c
index 06949754..14ef13fe 100644
--- a/arch/x86/boot/tools/build.c
+++ b/arch/x86/boot/tools/build.c
@@ -55,6 +55,8 @@ u8 buf[SETUP_SECT_MAX*512];
 #define PECOFF_COMPAT_RESERVE 0x0
 #endif
 
+static unsigned long efi32_stub_entry;
+static unsigned long efi64_stub_entry;
 static unsigned long efi_pe_entry;
 static unsigned long efi32_pe_entry;
 static unsigned long _end;
@@ -263,12 +265,31 @@ static void efi_stub_defaults(void)
 #endif
 }
 
+static void efi_stub_entry_update(void)
+{
+	unsigned long addr = efi32_stub_entry;
+
+#ifdef CONFIG_EFI_HANDOVER_PROTOCOL
+#ifdef CONFIG_X86_64
+	/* Yes, this is really how we defined it :( */
+	addr = efi64_stub_entry - 0x200;
+#endif
+
+#ifdef CONFIG_EFI_MIXED
+	if (efi32_stub_entry != addr)
+		die("32-bit and 64-bit EFI entry points do not match\n");
+#endif
+#endif
+	put_unaligned_le32(addr, &buf[0x264]);
+}
+
 #else
 
 static inline void update_pecoff_setup_and_reloc(unsigned int size) {}
 static inline void update_pecoff_text(unsigned int text_start,
 				      unsigned int file_sz) {}
 static inline void efi_stub_defaults(void) {}
+static inline void efi_stub_entry_update(void) {}
 
 static inline int reserve_pecoff_reloc_section(int c)
 {
@@ -311,6 +332,8 @@ static void parse_zoffset(char *fname)
 	p = (char *)buf;
 
 	while (p && *p) {
+		PARSE_ZOFS(p, efi32_stub_entry);
+		PARSE_ZOFS(p, efi64_stub_entry);
 		PARSE_ZOFS(p, efi_pe_entry);
 		PARSE_ZOFS(p, efi32_pe_entry);
 		PARSE_ZOFS(p, _end);
@@ -393,6 +416,7 @@ int main(int argc, char ** argv)
 
 	update_pecoff_text(setup_sectors * 512, i + (sys_size * 16));
 
+	efi_stub_entry_update();
 
 	crc = partial_crc32(buf, i, crc);
 	if (fwrite(buf, 1, i, dest) != i)
-- 
2.39.2

